import math

class decryptor:
    def __init__(self) -> None:
        self.final = ""
        self.Table = []
        self.input = []
        self.binary_str = ""
        self.final_output = ""
        self.section1 = ""
        self.section2 = ""
        self.section3 = ""
        self.section4 = ""
        self.encryptionHeader = []
        self.final_str = ""
        self.List = []
        self.iv = []
        self.hash = ""
        self.shiftValue = []  # Changed to list
        self.fileType = ""  #txt, doc, img from caller class.
        self.sec3choice = ""
        self.sec4choice = ""
        self.padding = ""

    def TakingInput(self, iencHeader):
        self.input = [item[0] for item in iencHeader]  # Flatten the list of lists to a list of strings 
        print(f"Received Input: {self.input}") 
        ls1 = []  # For IV
        ls2 = []  # For ShiftValue
        ls3 = []  # For hash

        for row in self.input: 
            print(f"\nProcessing row: {row}") 
            # Extract IV (e.g., IV: 12 -> ['1', '2']) 
            if "IV:" in row: 
                iv_string = row.split(':')[1].strip()  # Split by ':' 
                ls1 = int(iv_string)  # Convert to list of digits 
                self.iv = ls1 
                print(f"IV: {self.iv}") 

            # Extract Shift Value (e.g., This is the shifting value 123456 -> [1, 2, 3, 4, 5, 6]) 
            elif "shifting value" in row: 
                shift_string = row.split(':')[1].strip()  # Split by ':' 
                ls2 = int(shift_string)  # Convert each digit to an integer 
                self.shiftValue = ls2 
                print(f"ShiftValue: {self.shiftValue}") 
            elif "padding used" in row:
                pad = row.split(":")[1].strip()
                self.padding = pad
                print(f"Padding: {self.padding}")

            # Extract Hash (e.g., This is the hash value: ... -> hash value itself) 
            elif "hash value" in row: 
                self.hash = row.split(':')[1].strip()  # Split by ':' 
                print(f"Hash: {self.hash}") 
 
            # Etract Final Encrypted String (e.g., This is the final encrypted string: ... -> binary string) 
            elif "final encrypted string" in row: 
                self.final_str = row.split(':')[1].strip()  # Take the encrypted binary string 
                print(f"Encrypted binary string: {self.final_str}") 

            elif "block 3 method choice" in row: 
                self.sec3choice = row.split(':')[1].strip() 
                print(f"Method 3 choice: {self.sec3choice}") 

            elif "block 4 method choice" in row: 
                self.sec4choice = row.split(':')[1].strip() 
                print(f"Method 4 choice: {self.sec4choice}")

            if self.sec3choice is not None and self.sec4choice is not None and self.final_str is not None and self.hash is not None and self.iv is not None:
                print("Data successfully collected")
            else:
                print("Error in encryption header")
        


    def xor_binary(self, data, key):
        key = key * (len(data) // len(key)) + key[:len(data) % len(key)]  # Ensure key is long enough
        result = ''.join(str(int(d) ^ int(k)) for d, k in zip(data, key))
        return result
#
# TODO- Need to reverse the str (or work backwards), take the padding off, then split into 128
# blocks and un XOR them all, then combine them back together then do lots of debugging to see if it worked

    def decrypt(self):
        combined_int = self.final_str  # Assuming final_str holds the encrypted string
        count_128 = math.ceil(len(combined_int) / 128)
        print(f"Number of 128-character chunks: {count_128}")

        all_encrypted_blocks = []
        key = "01000000100010100000111111010000000010100000100101001101110110110111001100010110001001000101000011100011110001101111000001111001"

        for j in range(count_128):
            start_index = j * 128
            end_index = start_index + 128
            bits = combined_int[start_index:end_index]

            self.List = {'row': j, 'value': bits}
            self.final_str = int(self.List['value'], 2)
            self.final_str = bin(self.final_str)[2:]

            print("table:", self.List)

            s = self.xor_binary(self.final_str, key)
            print(f"XOR result for block {j}: {s}")

            all_encrypted_blocks.append(s)

        final_decrypted_string = ''.join(all_encrypted_blocks)
        print(f"Final decrypted result: {final_decrypted_string}")

        # Split into sections
        sections = self.split_into_sections(final_decrypted_string)
        print(f"Sections: {sections}")

        return final_decrypted_string

    def split_into_sections(self, input_string):
        section_length = len(input_string) // 4
        sections = [input_string[i:i + section_length] for i in range(0, len(input_string), section_length)]
        return sections

decryptor_instance = decryptor()

with open("output.txt", "r") as file:
    encHead = file.read().strip().splitlines()

encHead = [line.split(',') for line in encHead]

s = decryptor_instance.TakingInput(encHead)
print(f"\nDecryption Output: {s}")
